<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Bürgerchat — Demo (Chat Agent)</title>
<style>
  :root{
    --bav-royal:#00308F;
    --bav-sky:#4DA3FF;
    --bg:#f7fbff;
    --muted:#415069;
    --card:#ffffff;
    --accent:#FFD24A;
  }
  html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Roboto,Arial,sans-serif;background:var(--bg);color:var(--muted);font-size:14px}
  .wrap{display:flex;flex-direction:column;height:100%}
  header{background:linear-gradient(90deg,var(--bav-royal),var(--bav-sky));color:white;padding:10px 12px;display:flex;align-items:center;gap:10px}
  .title{font-weight:700}
  main{flex:1;overflow:auto;padding:12px}
  .messages{display:flex;flex-direction:column;gap:10px;max-width:100%}
  .msg{padding:10px;border-radius:10px;max-width:86%;line-height:1.4}
  .user{align-self:flex-end;background:linear-gradient(180deg,#e6f0ff,#d9ecff);color:#04204a}
  .bot{align-self:flex-start;background:#fff;border:1px solid rgba(0,48,143,0.06);color:var(--muted)}
  .meta{font-size:12px;color:#6b7280;margin-top:6px}
  .controls{display:flex;gap:8px;padding:10px;border-top:1px solid rgba(0,0,0,0.04);background:rgba(255,255,255,0.6)}
  input[type="text"]{flex:1;padding:10px;border-radius:10px;border:1px solid #dfe9ff}
  button{background:var(--bav-royal);color:white;border:none;padding:9px 12px;border-radius:8px;cursor:pointer}
  button.secondary{background:transparent;border:1px solid rgba(0,0,0,0.06);color:var(--muted)}
  .status{font-size:12px;color:#51607a;margin-left:8px}
  .spinner{width:14px;height:14px;border-radius:50%;border:2px solid rgba(0,0,0,0.12);border-top-color:var(--bav-royal);animation:spin 1s linear infinite;display:inline-block;vertical-align:middle}
  @keyframes spin{to{transform:rotate(360deg)}}
  .progressive{font-family:monospace;white-space:pre-wrap;word-break:break-word}
  .error{color:#9b1c1c;background:#fff0f0;border:1px solid #f2c2c2}
  .hint{font-size:12px;color:#6b7280;padding:8px}
</style>
</head>
<body>
<div class="wrap" role="application">
  <header>
    <div style="width:36px;height:36px;border-radius:8px;background:white;color:var(--bav-royal);display:flex;align-items:center;justify-content:center;font-weight:700">B</div>
    <div class="title">Bürgerchat (Demo)</div>
    <div style="margin-left:auto" id="connectionStatus" class="meta">Bereit</div>
  </header>

  <main id="main">
    <div class="messages" id="messages" aria-live="polite" aria-atomic="false">
      <div class="msg bot" id="welcome">
        <strong>Willkommen beim Bürgerchat (Demo)</strong>
        <div class="hint">Stellen Sie Fragen zur Meldeänderung. Dieses Demo sendet Nachrichten an eine REST-API (konfigurierbar).</div>
      </div>
    </div>
  </main>

  <div class="controls" role="region" aria-label="Chat controls">
    <input id="input" type="text" placeholder="Ihre Nachricht..." aria-label="Ihre Nachricht" />
    <button id="sendBtn">Senden</button>
    <button id="clearBtn" class="secondary" title="Chatverlauf löschen">Löschen</button>
    <div id="liveStatus" class="status" aria-live="polite"></div>
  </div>
</div>

<script>
/*
  Chat Agent (static) — communicates with a REST API.
  Usage: set API_BASE to your endpoint that accepts POST /messages and provides a messageId,
         and a GET /messages/:id or GET /messages/:id/stream to poll for results.

  This example implements:
    POST {role:'user', text:...} -> {messageId: 'abc123'}
    GET /messages/:id -> {status:'pending'|'complete'|'error', text: 'final text', error: '...'}
  It also supports server-sent-chunks via GET /messages/:id/stream returning text/event-stream (optional).
*/

const API_BASE = '/api'; // adjust to your API base (e.g., 'https://example.com/api')
const POLL_INTERVAL_MS = 1200;    // poll frequency while pending
const LONG_POLL_MS = 8000;        // if no update within this, show spinner/message
const messagesEl = document.getElementById('messages');
const inputEl = document.getElementById('input');
const sendBtn = document.getElementById('sendBtn');
const clearBtn = document.getElementById('clearBtn');
const liveStatus = document.getElementById('liveStatus');
const connectionStatus = document.getElementById('connectionStatus');

sendBtn.addEventListener('click', sendMessage);
inputEl.addEventListener('keydown', e => { if(e.key === 'Enter') sendMessage(); });
clearBtn.addEventListener('click', () => { messagesEl.innerHTML=''; addBotMessage('Willkommen beim Bürgerchat (Demo)\\nStellen Sie Fragen zur Meldeänderung.'); });

function addUserMessage(text){
  const d = document.createElement('div');
  d.className = 'msg user';
  d.textContent = text;
  messagesEl.appendChild(d);
  d.scrollIntoView({behavior:'smooth', block:'end'});
}
function addBotMessage(text, opts = {}){
  const d = document.createElement('div');
  d.className = 'msg bot';
  if(opts.error) d.classList.add('error');
  if(opts.progressive){
    const code = document.createElement('div');
    code.className = 'progressive';
    code.textContent = '';
    d.appendChild(code);
    d._progressEl = code;
  } else {
    d.textContent = text;
  }
  messagesEl.appendChild(d);
  d.scrollIntoView({behavior:'smooth', block:'end'});
  return d;
}

/* Minimal helper: POST message, then poll for result */
async function sendMessage(){
  const text = inputEl.value && inputEl.value.trim();
  if(!text) return;
  inputEl.value = '';
  addUserMessage(text);

  // Create a placeholder bot message with progressive behavior
  const placeholder = addBotMessage('', {progressive:true});
  placeholder._progressEl.textContent = 'Antwort wird vorbereitet...';
  liveStatus.textContent = 'Sende...';
  connectionStatus.textContent = 'Verbunden';

  try{
    const postResp = await fetch(API_BASE + '/messages', {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({role:'user', text})
    });
    if(!postResp.ok) throw new Error('Serverfehler beim Senden');
    const postJson = await postResp.json();
    const messageId = postJson && (postJson.messageId || postJson.id);
    if(!messageId) throw new Error('Ungültige Server-Antwort (keine ID)');

    liveStatus.textContent = 'Antwort wird erstellt…';
    // Try to use streaming endpoint first (if server supports text/event-stream or chunked)
    const streamUrl = API_BASE + '/messages/' + encodeURIComponent(messageId) + '/stream';
    const supportsStream = await tryStream(streamUrl, placeholder);
    if(!supportsStream){
      // fallback to polling
      await pollForResult(API_BASE + '/messages/' + encodeURIComponent(messageId), placeholder);
    }
  } catch(err){
    placeholder.textContent = 'Fehler: ' + err.message;
    placeholder.classList.add('error');
    liveStatus.textContent = 'Fehler';
    connectionStatus.textContent = 'Fehler';
  }
}

/* Attempt to connect to a text/event-stream endpoint and handle incremental chunks.
   Returns true if stream was used, false otherwise. */
async function tryStream(url, placeholder){
  // Attempt fetch with 'text/event-stream' or chunked transfer decoding.
  // Some servers may not allow CORS for SSE; handle failures gracefully.
  try{
    const resp = await fetch(url, {method:'GET', headers:{'Accept':'text/event-stream'}});
    if(!resp.ok) return false;
    const contentType = resp.headers.get('Content-Type') || '';
    if(!contentType.includes('text/event-stream') && !resp.body) return false;

    // If server returns SSE or chunked body, read stream.
    const reader = resp.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';
    let lastUpdate = Date.now();
    liveStatus.textContent = 'Streaming…';
    connectionStatus.textContent = 'Streaming';

    while(true){
      const {done, value} = await reader.read();
      if(done) break;
      const chunk = decoder.decode(value, {stream:true});
      buffer += chunk;
      // For SSE style, split by lines starting with "data: "
      // For plain chunked text, append as-is.
      // Try simple heuristics:
      if(buffer.indexOf('\\n') !== -1){
        // flush buffer periodically
        placeholder._progressEl.textContent = sanitizeForDisplay(buffer);
      } else {
        placeholder._progressEl.textContent = sanitizeForDisplay(buffer);
      }
      lastUpdate = Date.now();
      // auto-scroll
      placeholder.scrollIntoView({behavior:'smooth', block:'end'});
    }

    // final flush handled
    if(buffer && buffer.trim()){
      placeholder._progressEl.textContent = sanitizeForDisplay(buffer);
    } else {
      placeholder._progressEl.textContent = '(keine Antwort erhalten)';
    }
    liveStatus.textContent = 'Fertig';
    connectionStatus.textContent = 'Bereit';
    return true;
  } catch(err){
    // streaming not available / failed
    return false;
  }
}

/* Polling loop for non-streaming servers */
async function pollForResult(url, placeholder){
  let lastText = '';
  let startedAt = Date.now();
  let spinnerTimeout;
  const showSpinnerAfter = 1200;

  while(true){
    try{
      const resp = await fetch(url, {method:'GET', headers:{'Accept':'application/json'}});
      if(!resp.ok) throw new Error('Serverfehler beim Abfragen');
      const json = await resp.json();
      // expected: {status: 'pending'|'complete'|'error', text: '...'}
      if(json.status === 'error'){
        placeholder._progressEl.textContent = 'Fehler: ' + (json.error || 'Unbekannt');
        placeholder.classList.add('error');
        liveStatus.textContent = 'Fehler';
        connectionStatus.textContent = 'Fehler';
        return;
      }
      if(json.status === 'pending'){
        // show progressive indication: dots or partial text
        const now = Date.now();
        if(now - startedAt > showSpinnerAfter){
          liveStatus.textContent = 'Generierung läuft…';
          connectionStatus.textContent = 'Verarbeitung';
        }
        // If server provides partial text, show it
        if(json.partialText && json.partialText !== lastText){
          lastText = json.partialText;
          placeholder._progressEl.textContent = sanitizeForDisplay(lastText);
        } else {
          // animate ellipsis
          const dots = Math.floor(((Date.now()/400) % 4));
          placeholder._progressEl.textContent = 'Antwort wird generiert' + '.'.repeat(dots);
        }
        await sleep(POLL_INTERVAL_MS);
        continue;
      }
      if(json.status === 'complete'){
        const text = json.text || json.result || '';
        placeholder._progressEl.textContent = sanitizeForDisplay(text || '(leere Antwort)');
        liveStatus.textContent = 'Fertig';
        connectionStatus.textContent = 'Bereit';
        return;
      }
      // unknown status: wait and retry
      await sleep(POLL_INTERVAL_MS);
    } catch(err){
      // network or other error -> show message and retry a few times then fail
      placeholder._progressEl.textContent = 'Fehler beim Abrufen: ' + err.message;
      placeholder.classList.add('error');
      liveStatus.textContent = 'Fehler';
      connectionStatus.textContent = 'Offline';
      return;
    }
  }
}

/* Utilities */
function sleep(ms){ return new Promise(res=>setTimeout(res, ms)); }

function sanitizeForDisplay(s){
  if(!s) return '';
  // Basic escaping to avoid HTML injection in this demo
  return s.replace(/[&<>]/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;'}[c]));
}

/* Basic connection health check (optional) */
async function checkApiHealth(){
  try{
    const resp = await fetch(API_BASE + '/health', {method:'GET'});
    if(resp.ok){
      connectionStatus.textContent = 'Verbunden';
    } else {
      connectionStatus.textContent = 'Eingeschränkt';
    }
  } catch(e){
    connectionStatus.textContent = 'Offline';
  }
}
setInterval(checkApiHealth, 15000);
checkApiHealth();
</script>
</body>
</html>